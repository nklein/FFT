
(in-package #:fft)

(defun rearrange-samples (row)
  (declare (optimize (speed 3))
	   (type virtual-row row))
  (labels ((next-target (target mask)
	     (declare (type fixnum target mask))
	     (let ((mask (ash mask -1)))
	       (declare (type fixnum mask))
	       (cond
		 ((zerop (logand target mask)) (logior target mask))
		 (t (next-target (logandc2 target mask) mask))))))
    (loop :with len fixnum = (row-length row)
       :for target fixnum = 0 :then (next-target target len)
       :for pos fixnum :from 0 :below len
       :do (when (< target pos)
	     (rotatef (row-ref row target) (row-ref row pos)))))
  row)

(defun shift-samples (row)
  (declare (optimize (speed 3))
	   (type virtual-row row))
  (let* ((len (row-length row))
	 (mid (ash len -1)))
    (declare (type fixnum len mid))
    (dotimes (ii mid row)
      (declare (type fixnum ii))
      (rotatef (row-ref row ii) (row-ref row (+ ii mid))))))

(defun scale-samples (row)
  (declare (optimize (speed 3))
	   (type virtual-row row))
  (let ((len (row-length row)))
    (declare (type fixnum len))
    (let ((factor (sqrt (abs (coerce len 'double-float)))))
      (declare (type double-float factor))
      (let ((scale (/ factor)))
	(declare (type double-float scale))
	(dotimes (ii len row)
	  (declare (type fixnum ii))
	  (let ((scaled (* scale (row-ref row ii))))
	    (declare (type (complex double-float) scaled))
	    (setf (row-ref row ii) scaled)))))))

(deftype small-double-float ()
  '(double-float #.(- pi) #.pi))

(defun perform-fft (row &optional inverse)
  (declare (optimize (speed 3))
	   (type virtual-row row)
	   (type t inverse))
  (assert (zerop (logand (row-length row)
			 (1- (row-length row))))
	  (row)
	  "Row lenghth must be power of two, but is ~S" (row-length row))
  (when inverse
    (shift-samples row))
  (rearrange-samples row)
  (loop :with angular-scale double-float = (coerce (if inverse pi (- pi))
						   'double-float)
     :with len fixnum = (row-length row)
     :for step fixnum = 1 :then (* step 2)
     :while (< step len)
     :do (loop :with delta = (/ angular-scale step)
	    :with sine = (sin (the small-double-float (/ delta 2.0d0)))
	    :with multiplier = (complex (* -2.0d0 sine sine)
					(sin (the small-double-float delta)))
	    :for factor = (complex 1.0d0 0.0d0)
	         :then (+ (the (complex double-float) factor)
			  (the (complex double-float)
			    (* factor multiplier)))
	    :for group fixnum :from 0 :below step
	    :do (loop :for pair fixnum :from group :below len :by (* step 2)
		   :do (let ((match (+ pair step)))
			 (declare (type fixnum match))
			 (let ((product (* factor (row-ref row match))))
			   (declare (type (complex double-float) product))
			   (setf (row-ref row match)
				 (- (row-ref row pair) product))
			   (incf (row-ref row pair) product))))))
  (scale-samples row)
  (unless inverse
    (shift-samples row))
  row)

(defun make-dst-buf (src dst)
  (declare (optimize (speed 3))
	   (type array src)
	   (type (or (array (complex double-float)) null) dst))
  (labels ((copy-array (src dst)
	     (declare (type array src)
		      (type (array (complex double-float)) dst))
	     (let ((size (array-total-size src)))
	       (dotimes (ii size dst)
		 (setf (row-major-aref dst ii)
		       (coerce (row-major-aref src ii)
			       '(complex double-float))))))
	   (clone-array (src)
	     (declare (type array src))
	     (let ((dst (make-array (array-dimensions src)
				    :element-type '(complex double-float)
				    :initial-element (complex 0.0d0 0.0d0))))
	       (copy-array src dst))))
    (cond
      ((null dst) (clone-array src))
      ((and (eq src dst)
	    (typep (row-major-aref dst 0)
		   '(complex double-float))) dst)
      ((equal (array-dimensions src)
	      (array-dimensions dst)) (copy-array src dst))
      (t (error "Incompatible source and destination")))))

(defun fft (src &optional dst)
  (let ((dst (make-dst-buf src dst)))
    (loop :for row = (virtual-row dst) :then (next-row row)
       :while row
       :do (perform-fft row nil))
    dst))

(defun ifft (src &optional dst)
  (let ((dst (make-dst-buf src dst)))
    (loop :for row = (virtual-row dst) :then (next-row row)
       :while row
       :do (perform-fft row t))
    dst))
